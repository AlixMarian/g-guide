//VisitaIglesia.jsx

import '../websiteUser.css';
import visLogo from '/src/assets/visLogo.png';
import { useNavigate } from 'react-router-dom';
import React, { useState, useEffect, useRef } from 'react';
import { GoogleMap, LoadScript, DirectionsRenderer, Marker } from '@react-google-maps/api';
import { Offcanvas, Button, Form, Modal } from 'react-bootstrap';
import { fetchChurchData } from './mapfiles/churchDataUtils';
import loadingGif from '../assets/Ripple@1x-1.0s-200px-200px.gif';
import { handleMarkerClick as utilHandleMarkerClick, handleMapLoad, onZoomChanged } from './mapfiles/churchDataUtils';
import AutoGen from './mapfiles/AutoGen';
import coverLogo from '/src/assets/logo cover.png';
import ChurchAutocomplete from './mapfiles/ChurchAutocomplete';
import SearchFilter from './mapfiles/SearchFilter'; // Add this import


const VisitaIglesia = () => {
  const navigate = useNavigate();
  const [churches, setChurches] = useState([]);
  const [directionsResponse, setDirectionsResponse] = useState([]);
  const [travelMode, setTravelMode] = useState('DRIVING');
  const [map, setMap] = useState(null);
  const [loading, setLoading] = useState(true);
  const [currentPosition, setCurrentPosition] = useState(null);
  const [startLocation, setStartLocation] = useState(null);
  const [customIcon, setCustomIcon] = useState(null);
  const [showOffcanvas, setShowOffcanvas] = useState(false);
  const [showAutoGen, setShowAutoGen] = useState(false);
  const handleToggleOffcanvas = () => setShowOffcanvas(!showOffcanvas);
  const [mapLoaded, setMapLoaded] = useState(false);
  const [mapKey, setMapKey] = useState(0);
  const [endLocation, setEndLocation] = useState(null); 
  const currentZoomRef = useRef(14); // Default zoom level
  const [sortedChurches, setSortedChurches] = useState([]);
  const [churchPhoto, setChurchPhoto] = useState(coverLogo);  
  const [markers, setMarkers] = useState([]);
  const [zoomLevel, setZoomLevel] = useState(14); // Default zoom level
  const [showDirectionsOffcanvas, setShowDirectionsOffcanvas] = useState(false);
  const [isRouteCalculated, setIsRouteCalculated] = useState(false);
  const [isAutoGenRoute, setIsAutoGenRoute] = useState(false);
  const [showInstructions, setShowInstructions] = useState(false);


  const handleOffcanvasClose = () => {
    setShowDirectionsOffcanvas(false);
  };

  const handleMarkerClick = (church) => {
    utilHandleMarkerClick(church, setDrawerInfo, setChurchPhoto);
  };
 
  const containerStyle = {
    width: '100vw', 
    height: '100vh', 
  }; 
  const libraries = ['places', 'geometry'];
  const colors = ["#FF0000", "#00FF00", "#0000FF", "#FF00FF", "#00FFFF", "#FFA500"];

  useEffect(() => {
    if (map && mapKey) {
      // map.setZoom(14); // Remove or comment this out
    }
  }, [mapKey]);
  

  const [drawerInfo, setDrawerInfo] = useState({
    show: false,
    id: '',
    title: '',
    description: '',
    telephone: '',
    churchStartTime: '',
    churchEndTime: '',
    status: '',
    churchStatus: '',
  });

  const [destinations, setDestinations] = useState([
    {
      id: 'dest-0',
      destination: null,
      // usingCustomDestination: false,
      // inputValue: '',
      selectedChurchId: '',
    },
  ]);

    const handleAutoGeneratedRoute = (origin, churches, endLocation) => {
    if (!window.google) {
      console.error('Google Maps API is not available.');
      return;
    }

    setIsAutoGenRoute(true);

    const directionsService = new window.google.maps.DirectionsService();

    // First, compute the initial route between origin and endLocation
    directionsService.route(
      {
        origin: origin,
        destination: endLocation,
        travelMode: window.google.maps.TravelMode.DRIVING,
      },
      (initialResult, status) => {
        if (status === window.google.maps.DirectionsStatus.OK) {
          const routePolyline = initialResult.routes[0].overview_path;

          // Find churches along the route
          let nearbyChurches = [];
          let radiusKm = 1;
          const maxRadiusKm = 20; // Increase max radius to ensure we find enough churches
          const incrementKm = 1;

          // Keep increasing radius until we find at least 7 churches
          while (nearbyChurches.length < 7 && radiusKm <= maxRadiusKm) {
            nearbyChurches = findChurchesAlongRoute(churches, routePolyline, radiusKm);
            radiusKm += incrementKm;
          }

          // If we still don't have enough churches, add the closest remaining churches
          if (nearbyChurches.length < 7) {
            const remainingChurches = churches.filter(
              church => !nearbyChurches.some(nc => nc.id === church.id)
            );
            
            // Sort remaining churches by distance to route
            const sortedRemaining = remainingChurches.sort((a, b) => {
              const aDistance = getMinDistanceToRoute(a, routePolyline);
              const bDistance = getMinDistanceToRoute(b, routePolyline);
              return aDistance - bDistance;
            });

            // Add closest churches until we have 7
            nearbyChurches = [...nearbyChurches, ...sortedRemaining.slice(0, 7 - nearbyChurches.length)];
          }

          // Take exactly 7 churches
          const selectedChurches = nearbyChurches.slice(0, 7);

          // Continue with the existing waypoints and routing logic...
          const waypoints = selectedChurches.map((church) => ({
            location: {
              lat: parseFloat(church.latitude),
              lng: parseFloat(church.longitude),
            },
            stopover: true,
          }));

          // Now, compute the route with waypoints
          directionsService.route(
            {
              origin: origin,
              destination: endLocation,
              waypoints: waypoints,
              optimizeWaypoints: true,
              travelMode: window.google.maps.TravelMode.DRIVING,
            },
            (result, status) => {
              if (status === window.google.maps.DirectionsStatus.OK) {
                // Map each leg with its respective color
                const routeLegs = result.routes[0].legs;

                const directionsWithColors = routeLegs.map((leg, index) => ({
                  result: {
                    ...result,
                    routes: [{ ...result.routes[0], legs: [leg] }],
                  },
                  color: colors[index % colors.length],
                }));

                setDirectionsResponse(directionsWithColors); 

                
                setDirectionsResponse([]); // comment if u wanna use the lines


                // The waypoint_order gives the optimized order of the waypoints
                const waypointOrder = result.routes[0].waypoint_order;

                const orderedChurches = waypointOrder.map((index) => selectedChurches[index]);

                // Assign labels to markers dynamically
                const markers = [
                  ...orderedChurches.map((church, idx) => ({
                    label: String.fromCharCode('A'.charCodeAt(0) + idx),
                    position: {
                      lat: parseFloat(church.latitude),
                      lng: parseFloat(church.longitude),
                    },
                  })),
                  
                ];

                if (map) {
                  const bounds = new window.google.maps.LatLngBounds();
                  
                  // Add origin and destination to bounds
                  bounds.extend(origin);
                  bounds.extend(endLocation);
                  
                  // Add all waypoints to bounds
                  waypoints.forEach(waypoint => {
                    bounds.extend(waypoint.location);
                  });
                  
                  map.fitBounds(bounds);
                  
                  // Add a slight delay before checking and adjusting zoom
                  setTimeout(() => {
                    const currentZoom = map.getZoom();
                    if (currentZoom > 15) {
                      map.setZoom(15);
                    }
                  }, 100);
                }

                setMarkers(markers);
                setSortedChurches(orderedChurches);
                setStartLocation(origin);
                setEndLocation(endLocation);
                setShowOffcanvas(false);
                console.log('Ordered Churches:', orderedChurches);
              } else {
                console.error('Error fetching directions:', status);
              }
            }
          );
        } else {
          console.error('Error fetching initial route:', status);
        }
      }
    );
  };

  // Function to find churches along the route
  const findChurchesAlongRoute = (churches, routePolyline, maxDistanceKm) => {
    return churches.filter((church) => {
      const churchLocation = new window.google.maps.LatLng(
        parseFloat(church.latitude),
        parseFloat(church.longitude)
      );

      // Check if the church is within maxDistanceKm of any point along the route
      const isNearby = routePolyline.some((routePoint) => {
        const distance =
          window.google.maps.geometry.spherical.computeDistanceBetween(routePoint, churchLocation) /
          1000; // Convert to km
        return distance <= maxDistanceKm;
      });

      return isNearby;
    });
  };
  
  
  const destinationRefs = useRef([React.createRef()]);
  const portal = useRef(document.createElement('div'));

  useEffect(() => {
    const offcanvasBody = document.querySelector('.offcanvas-body');
    if (offcanvasBody) {
      offcanvasBody.appendChild(portal.current);
    }
    return () => {
      if (offcanvasBody && portal.current.parentNode === offcanvasBody) {
        offcanvasBody.removeChild(portal.current);
      }
    };
  }, []);

  useEffect(() => {
    const loadGoogleMapsScript = () => {
      if (window.google && window.google.maps) {
        setMapLoaded(true);
        setLoading(false);
        return;
      }

      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=${import.meta.env.VITE_GOOGLE_MAPS_API_KEY}&libraries={libraries}`;
      script.async = true;
      script.defer = true;

      script.onload = () => {
        console.log('Google Maps script loaded successfully');
        setMapLoaded(true);
        setLoading(false);
      };

      script.onerror = (error) => {
        console.error('Error loading Google Maps script:', error);
        setLoading(false);
      };

      document.head.appendChild(script);
    };

  loadGoogleMapsScript();
  },
)

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      const data = await fetchChurchData();
      setChurches(data);
      setLoading(false);
    };

    fetchData();
  }, []);

  useEffect(() => {
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        (position) => {
          setCurrentPosition({
            lat: position.coords.latitude,
            lng: position.coords.longitude,
          });
        },
        (error) => console.error('Error getting current position:', error)
      );
    }
  }, []);

  const addDestination = () => {
    const newDestination = {
      id: `dest-${Date.now()}`,
      destination: null,
      // usingCustomDestination: false,
      // inputValue: '',
      selectedChurchId: '',
    };
    setDestinations([...destinations, newDestination]);
    // destinationRefs.current.push(React.createRef());
  };

  const uniqueDestinations = destinations
    .map((d) => d.destination)
    .filter(
      (dest, index, self) =>
        dest &&
        self.findIndex(
          (d) => d.lat === dest.lat && d.lng === dest.lng
        ) === index
    );

    const handleCalculateRoute = async () => {
      if (!startLocation) {
        alert('Please select a start location.');
        return;
      }
    
      if (uniqueDestinations.length === 0) {
        alert('Please select or enter valid destinations.');
        return;
      }

      setIsRouteCalculated(true);
    
      const allLocations = [startLocation, ...uniqueDestinations];
      const newDirections = [];
      const newMarkers = [
        {
          label: 'A',
          position: startLocation
        },
        ...uniqueDestinations.map((dest, index) => ({
          label: String.fromCharCode('B'.charCodeAt(0) + index),
          position: dest
        }))
      ];
    
      try {
        for (let i = 0; i < allLocations.length - 1; i++) {
          const directionsService = new window.google.maps.DirectionsService();
          const routeSegment = await new Promise((resolve, reject) => {
            directionsService.route(
              {
                origin: allLocations[i],
                destination: allLocations[i + 1],
                travelMode: window.google.maps.TravelMode[travelMode]
              },
              (result, status) => {
                if (status === window.google.maps.DirectionsStatus.OK) {
                  resolve({
                    result,
                    color: colors[i % colors.length],
                  });
                } else {
                  reject(`Error fetching directions for segment ${i + 1}: ${status}`);
                }
              }
            );
          });
    
          newDirections.push(routeSegment);
        }
    
        setDirectionsResponse(newDirections);
        setMarkers(newMarkers);

        // Fit bounds but maintain zoom control
        if (map) {
          const bounds = new window.google.maps.LatLngBounds();
          allLocations.forEach(location => bounds.extend(location));
          map.fitBounds(bounds);
          
          // Add a slight delay before allowing zoom changes
          setTimeout(() => {
            // Get the current zoom after bounds fit
            const currentZoom = map.getZoom();
            // Set maximum zoom level if too zoomed in
            if (currentZoom > 15) {
              map.setZoom(15);
            }
          }, 100);
        }

      } catch (error) {
        console.error(error);
        alert('Failed to calculate route. Please check your inputs.');
      }
    };

  const resetRoutes = () => {
    setMapKey((prevKey) => prevKey + 1);
    setDirectionsResponse([]);
    setMarkers([]); 

    setDestinations([
      {
        id: 'dest-0',
        destination: null,
        usingCustomDestination: false,
        inputValue: null,
        selectedChurchId: null,
      },
    ]);
    setStartLocation(null);
    setEndLocation(null);
    setSortedChurches([]);
    setIsRouteCalculated(false);
    setIsAutoGenRoute(false);
  
    console.log('Routes and destinations reset.');
  };
  
  return loading ? (
    <div style={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}>
      <img src={loadingGif} alt="Loading Google Maps..." style={{ width: '100px', justifyContent: 'center' }} />
    </div>
  ) : !mapLoaded ? (
    <div style={{ textAlign: 'center', marginTop: '20vh' }}>
      <p>Unable to load Google Maps. Please check your API key or network connection.</p>
    </div> 
  ) : (
    <>
    <LoadScript googleMapsApiKey={import.meta.env.VITE_GOOGLE_MAPS_API_KEY} libraries={libraries} onLoad={() => {console.log('Google Maps API loaded'); setMapLoaded(true); setLoading(false); }} onError={(error) => {console.error('Google Maps API loading error:', error); setLoading(false);}}> 
      <Button variant="primary" style={{ zIndex: '999', position: 'absolute', top: '10px', left: '190px' }} onClick={() => setShowOffcanvas(true)} >
        Visita Iglesia Routes
      </Button>
      <Button variant="primary" style={{ zIndex: '999', position: 'absolute', top: '10px', right: '60px' }} onClick={() => navigate('/map')}>
        <i className="bi bi-arrow-return-left"></i>
      </Button> 
      <Offcanvas show={showOffcanvas} style={{ zIndex: '9999' }} onHide={() => setShowOffcanvas(false)} placement="start">
      <Offcanvas.Header closeButton>
        <Offcanvas.Title>
          <img src={visLogo} alt="Visita Iglesia" style={{width: '25px', height: '25px', objectFit: 'contain'}} />
          Visita Iglesia
        </Offcanvas.Title>
      </Offcanvas.Header>
      <Offcanvas.Body>
      {showAutoGen ? (
      <AutoGen onBack={() => setShowAutoGen(false)} resetRoutes={resetRoutes} churches={churches} currentPosition={currentPosition} handleAutoGeneratedRoute={handleAutoGeneratedRoute} />
      ) : ( 
      <Form>
        <Form.Group controlId="start-church" className="mb-3">
          <Form.Label>Select Start Location</Form.Label>
          <ChurchAutocomplete
            churches={churches}
            onChurchSelected={(selectedChurch) => {
              const lat = Number(selectedChurch.latitude);
              const lng = Number(selectedChurch.longitude);
              if (!isNaN(lat) && !isNaN(lng)) {
                setStartLocation({ lat, lng });
                // setStartChurchId(selectedChurch.id); // Optional: if you need to track the selected church ID
              } else {
                console.error('Invalid coordinates:', selectedChurch);
              }
            }}
            placeholder="Enter Start Location"
          />
        </Form.Group>

        {destinations.map((dest, index) => (
          <div key={dest.id} className="destination-item d-flex align-items-center mb-3 position-relative w-100">
            <div className="flex-grow-1">
              <ChurchAutocomplete
                churches={churches}
                onChurchSelected={(selectedChurch) => {
                  console.log('Selected Destination:', selectedChurch);
                  const lat = Number(selectedChurch.latitude);
                  const lng = Number(selectedChurch.longitude);

                  // Validate coordinates
                  if (!isNaN(lat) && !isNaN(lng)) {
                    const updatedDestinations = [...destinations];
                    updatedDestinations[index].destination = { lat, lng };
                    setDestinations(updatedDestinations);
                  } else {
                    console.error('Invalid coordinates:', selectedChurch);
                  }
                }}
                placeholder="Enter Destination"
              />
            </div>
            <Button
              variant="link"
              className="delete-div-btn ms-2"
              onClick={() => {
                setDestinations((prevDestinations) => prevDestinations.filter((_, i) => i !== index));
                handleCalculateRoute();
              }}
            >
              <i className="bi bi-x-circle-fill"></i>
            </Button>
          </div>
        ))}

        
        <div className="text-center">
          <Button variant="primary" onClick={addDestination} className="d-flex justify-content-center align-items-center px-3 py-2 rounded mb-5 mt-3 mx-auto w-70" style={{ height: '35px' }}>
            + Add another Church Destination
          </Button>
        </div>
        <div className="d-flex align-items-center">
          <Button onClick={handleCalculateRoute} variant="primary" className="flex-grow-1 me-2 fw-bold]" disabled={isRouteCalculated}>
            Get Route
          </Button>
          <Button variant="outline-danger" className="px-4" onClick={resetRoutes}>
            Reset
          </Button>
        </div>
        <div className='text-center'>
          <p style={{marginTop: '1rem', marginBottom: '-0.01rem'}}>or</p>
          {!showAutoGen && (
            <Button variant="success" onClick={() => {setShowAutoGen(true); resetRoutes(); }} className='d-flex justify-content-center align-items-center px-3 py-2 rounded mb-5 mt-1 mx-auto w-75' style={{ height: '35px', marginTop: '-4rem' }}>
              use Auto Generate
            </Button>
          )}
        </div>
        <div className="d-flex align-items-start text-muted small ms-1" style={{marginTop: '-1rem'}}>
          <i 
            className="bi bi-info-circle me-1 text-danger" 
            style={{fontSize: '20px', cursor: 'pointer', marginTop: '13rem'}}
            onClick={() => setShowInstructions(true)}
          ></i>
          <span className='fst-italic' style={{fontSize: '12px', marginTop: '13.38rem'}}>
            How to use?
          </span>
        </div>
      </Form> 
      )}
      <Modal
        show={showInstructions}
        onHide={() => setShowInstructions(false)}
        container={document.querySelector('.offcanvas-body')}
        style={{ position: 'absolute', marginTop: '22.5rem', width: '20rem', marginLeft: '2rem'}}
      >
        <Modal.Header closeButton>
          <Modal.Title className="fs-6">How to Use Visita Iglesia?</Modal.Title>
        </Modal.Header>
        <Modal.Body>
          <ol className="small mb-0 ps-3">
            <li>Select your starting church location</li>
            <li>Add more church destinations as needed</li>
            <li>Select churches from the dropdown list</li>
            <li>Remove destinations using X button</li>
            <li>Click "Get Route" to generate path</li>
            <li>Use "Reset" to start over</li>
          </ol>
        </Modal.Body>
      </Modal>
      </Offcanvas.Body>
        </Offcanvas>
        <div className="google-map-container">
        <GoogleMap
          key={mapKey}
          mapContainerStyle={containerStyle}
          center={currentPosition || { lat: 0, lng: 0 }}
          zoom={zoomLevel}
          onLoad={(mapInstance) => {
            handleMapLoad(mapInstance, setMap, setCustomIcon, setLoading);
            setMap(mapInstance);
          }}
          onZoomChanged={() => {
            if (map) {
              onZoomChanged(map, setCustomIcon);
            }
          }}
        >


      {currentPosition && <Marker position={currentPosition} />} 
      {churches.map((church) => {
        const lat = parseFloat(church.latitude);
        const lng = parseFloat(church.longitude);
        if (!isNaN(lat) && !isNaN(lng)) {
          return (
            <Marker
              key={church.id}
              position={{ lat, lng }}
              icon={customIcon}
              onClick={() => handleMarkerClick(church)}
            />
          );
        }
        return null;
      })}

      {/* Render the directions if available */}
      {directionsResponse?.map((segment, index) => (
        <DirectionsRenderer
          key={index}
          options={{
            directions: segment.result,
            polylineOptions: {
              strokeColor: segment.color,
              strokeOpacity: 0.8,
              strokeWeight: 5,
            },
            suppressMarkers: true,
            preserveViewport: true  
          }}
        />
      ))}

      {markers.map((marker, index) => (
        <Marker
          key={`marker-${index}`}
          position={marker.position}
          label={{
            text: marker.label,
            color: 'white',
            fontWeight: 'bold',
            fontSize: '16px',
          }}
          onClick={() => {
            setShowDirectionsOffcanvas(true);
          }}
        />
      ))}


      {/* If not using AutoGen, render markers for destinations */}
      {sortedChurches.length === 0 &&
        !loading &&
        uniqueDestinations.map((dest, index) => (
          <Marker
            key={`${dest.lat}-${dest.lng}`}
            position={dest}
            label={{
              text: String.fromCharCode('B'.charCodeAt(0) + index),
              color: 'white',
              fontWeight: 'bold',
              fontSize: '16px',
            }}
            
            onClick={() => {
              setShowDirectionsOffcanvas(true); 
            }}
          />
        ))}
     </GoogleMap>
    {/* List View Destinations */}
     <Offcanvas 
        show={showDirectionsOffcanvas}
        onHide={handleOffcanvasClose}
        placement="end"
        className="custom-offcanvas"
        style={{ maxHeight: 'fit-content', top: '3rem' }}
      >
        <Offcanvas.Header closeButton>
          <Offcanvas.Title>Church Destinations</Offcanvas.Title>
        </Offcanvas.Header>
        {isAutoGenRoute && (
          <div className="d-flex align-items-start text-muted small ms-3" style={{marginTop: '-1rem'}}>
            <i className="bi bi-info-circle me-1 text-danger"></i>
            <span className='text-justify fst-italic' style={{fontSize: '12px'}}>
              Suggested churches are provided; the choice of route is yours.
            </span>
          </div>
        )}
        <Offcanvas.Body>
           {/* Add a scrollable container */}
          {/* <div style={{ 
            maxHeight: '50vh', 
            overflowY: 'auto',
            paddingRight: '10px'
          }}></div> */}
          {startLocation && !sortedChurches.length && (
            <div className="py-2 border-bottom">
              <h6 className="mb-1 d-flex align-items-center">
              <span className="badge rounded-circle bg-white d-flex align-items-center justify-content-center me-2"
                style={{ width: '25px', height: '25px', background: 'linear-gradient(to right, #ff0000, #ff8000)' }}>
                  A
                </span>
                {churches.find(c => 
                  parseFloat(c.latitude) === startLocation.lat && 
                  parseFloat(c.longitude) === startLocation.lng
                )?.churchName || 'Custom Location'}
              </h6>
              <p className="ms-4 mb-0 text-muted">
              {churches.find(c => 
                parseFloat(c.latitude) === startLocation.lat && 
                parseFloat(c.longitude) === startLocation.lng
              )?.churchLocation || 'Custom Location'}
            </p>
            </div>
          )}

          {/* Destinations */}
          {uniqueDestinations.map((dest, index) => {
            const church = churches.find(c => 
              parseFloat(c.latitude) === dest.lat && 
              parseFloat(c.longitude) === dest.lng
            );
            
            return (
              <div key={index} className="py-2 border-bottom">
                <h6 className="mb-1 d-flex align-items-center">
                <span className="badge rounded-circle bg-white d-flex align-items-center justify-content-center me-2"
                  style={{ width: '25px', height: '25px', background: 'linear-gradient(to right, #ff0000, #ff8000)' }}>
                    {String.fromCharCode('B'.charCodeAt(0) + index)}
                  </span>
                  {church?.churchName || 'Custom Location'}
                </h6>
                <p className="ms-4 mb-0 text-muted">
                  {church?.churchLocation || 'Custom Address'}
                </p>
              </div>
            );
          })}

      {sortedChurches.map((church, idx) => (
        <div key={idx} className="py-2 border-bottom">
          <h6 className="mb-1 d-flex align-items-center">
            <span className="badge rounded-circle bg-white d-flex align-items-center justify-content-center me-2"
                  style={{ width: '25px', height: '25px', background: 'linear-gradient(to right, #ff0000, #ff8000)' }}>
              {String.fromCharCode('A'.charCodeAt(0) + idx)}
            </span>
            {church.churchName || 'Church Name Not Available'}
          </h6>
          <p className="ms-4 mb-0 text-muted">
            {church.churchLocation || 'Location Not Available'}
          </p>
        </div>
      ))}
        </Offcanvas.Body>
      </Offcanvas>
      </div>
    </LoadScript>
    <SearchFilter
      showMenu={false} // We don't need the menu functionality
      handleCloseMenu={() => {}} // Empty function since we don't use the menu
      handlePlaceSelected={() => {}} // Empty function since we don't use search
      selectedService=""
      handleServiceChange={() => {}}
      servicesList={[]}
      loading={loading}
      filteredChurches={[]}
      handleCancel={() => {}}
      selectedLanguage=""
      handleLanguageChange={() => {}}
      drawerInfo={drawerInfo}
      setDrawerInfo={setDrawerInfo}
      churchPhoto={churchPhoto}
      setChurchPhoto={setChurchPhoto}
      showOtherDatesButton={() => {}}
      handleShowAllDates={() => {}}
      status=""
    />
  </>
  );
};

export default VisitaIglesia;
